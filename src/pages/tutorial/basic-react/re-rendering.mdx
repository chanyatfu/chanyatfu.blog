import { Tabs } from 'nextra/components'

## Remark
This article is a summarisation of the book [Advanced React](https://www.advanced-react.com) by Nadia Makarevich. I highly recommend you to read the book if you want to learn more about React.
- This article assumes that you have some basic understanding of React's state, how it affects the re-rendering process, and the Virtual DOM.
- The component mentioned in the following article refers to the functional component in React.


## Common Misconception

- Re-render only occurs when the props of a component has changed.
- Use `React.memo` and `useCallback` as the primary solution to prevent excessive re-rendering.

## Component VS Element: What is the difference?

Component is simply a function that return a Element (which is a JavaScript object). When you write a component in React, it usually looks something like this:

<Tabs items={['Original', 'Underlying']}>
  <Tabs.Tab>
    ```jsx copy {3}
      const Component = () => {
        return (
          <Children />
        )
      }
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```jsx copy {3}
      const Component = () => {
        return (
          React.createElement(Children, null, null)
        )
      }
    ```
  </Tabs.Tab>
</Tabs>


The jsx syntax (`<Children />`) is actually a syntax sugar for `React.createElement(Children, null, null)`. `React.createElement` returns a ReactElement, which is a JavaScript object that represents a DOM node. Take `<Children />` as an example, the object return would be:
```jsx /Children/
{
  type: Children,
  props: {},
  // ... some other field
}
```

## How does it affect the re-render process?

Let's take a look at how components and elements affect the re-render process in React.

A re-render is triggered by state change. What it does is simply executing the component function again, which will then returns a new Element object. The new Element object is then compared with the old Element object. If they are the same, the re-render process will stop propagating. Otherwise, it will propagate the the nested components.

But there is a catch. The reference of the Element is compared. That means a re-render will (almost) certainly keep on ripple down to a component's children, as a new Element object is created every time the component is executed. Therefore, no matter if the props of a component has changed or not, a re-render will always occur (assumed that no memo is used) if the parent component re-render.

## Re-render = DOM update?

Short answer: No. a re-render does not necessarily mean a DOM update, but a DOM update is always triggered by a re-render.

The re-render process execute the component function and obtain a new set of Element object, which forms a new Virtual DOM. The old and the new Virtual DOM is then compared, which is called the reconciliation process. Keeps in mind that only that part that have been re-rendered will be compared. The reconciliation process determined if an update is needed, and if so, what is the update. The update is then applied to the real DOM.